

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>biogeme.models.models_orig &mdash; Biogeme 3.2.14 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=0b773b56"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Biogeme
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Install</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../code/toml.html">Configuration parameters</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../code/native_draws.html">Native draws</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../code/biogeme.html">.biogeme module</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Biogeme</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">biogeme.models.models_orig</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for biogeme.models.models_orig</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot; Implements various models.</span>

<span class="sd">:author: Michel Bierlaire</span>
<span class="sd">:date: Fri Mar 29 17:13:14 2019</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">biogeme.distributions</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">dist</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">biogeme.exceptions</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">excep</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">biogeme.expressions</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">expr</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">biogeme.nests</span><span class="w"> </span><span class="kn">import</span> <span class="n">NestsForNestedLogit</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="loglogit">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.loglogit">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">loglogit</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The logarithm of the logit model</span>

<span class="sd">    The model is defined as</span>

<span class="sd">    .. math:: \\frac{a_i e^{V_i}}{\\sum_{i=1}^J a_j e^{V_j}}</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>

<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param av: dict of objects representing the availability of each</span>
<span class="sd">               alternative (:math:`a_i` in the above formula), indexed</span>
<span class="sd">               by numerical ids. Must be consistent with util, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type av: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param i: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type i: int</span>

<span class="sd">    :return: choice probability of alternative number i.</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">av</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">_bioLogLogitFullChoiceSet</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">av</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">choice</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">_bioLogLogit</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span></div>



<div class="viewcode-block" id="loglogit_sampling">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.loglogit_sampling">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">loglogit_sampling</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">correction</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The logarithm of the logit model, with samples of alternatives</span>

<span class="sd">    The model is defined as</span>

<span class="sd">    .. math:: \\frac{a_i e^{V_i + \\log \\pi_i}}{\\sum_{i=1}^J a_j e^{V_j+\\log \\pi_j}}</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>

<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param av: dict of objects representing the availability of each</span>
<span class="sd">               alternative (:math:`a_i` in the above formula), indexed</span>
<span class="sd">               by numerical ids. Must be consistent with util, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type av: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param correction: a dict of expressions for the correstion terms</span>
<span class="sd">                       of each alternative.</span>
<span class="sd">    :type correction: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param i: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type i: int</span>

<span class="sd">    :return: choice probability of alternative number i.</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">V</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">!=</span> <span class="n">correction</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">error_msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;The keys of the correction must be the same as the keys of &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;the utilities. Correction: </span><span class="si">{</span><span class="n">correction</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s1">. &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;Utilities: </span><span class="si">{</span><span class="n">V</span><span class="o">.</span><span class="n">keys</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">BiogemeError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
    <span class="n">corrected_V</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="o">-</span> <span class="n">correction</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">V</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">return</span> <span class="n">loglogit</span><span class="p">(</span><span class="n">corrected_V</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span></div>



<div class="viewcode-block" id="logit">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.logit">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">logit</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The logit model</span>

<span class="sd">    The model is defined as</span>

<span class="sd">    .. math:: \\frac{a_i e^{V_i}}{\\sum_{i=1}^J a_j e^{V_j}}</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>

<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param av: dict of objects representing the availability of each</span>
<span class="sd">               alternative (:math:`a_i` in the above formula), indexed</span>
<span class="sd">               by numerical ids. Must be consistent with util, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type av: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param i: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type i: int</span>

<span class="sd">    :return: choice probability of alternative number i.</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">av</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">_bioLogLogitFullChoiceSet</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">av</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">choice</span><span class="o">=</span><span class="n">i</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">_bioLogLogit</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span></div>



<div class="viewcode-block" id="boxcox">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.boxcox">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">boxcox</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Box-Cox transform</span>

<span class="sd">    .. math:: B(x, \\ell) = \\frac{x^{\\ell}-1}{\\ell}.</span>

<span class="sd">    It has the property that</span>

<span class="sd">    .. math:: \\lim_{\\ell \\to 0} B(x,\\ell)=\\log(x).</span>

<span class="sd">    To avoid numerical difficulties, if :math:`\\ell &lt; 10^{-5}`,</span>
<span class="sd">    the McLaurin approximation is used:</span>

<span class="sd">    .. math:: \\log(x) + \\ell \\log(x)^2 + \\frac{1}{6} \\ell^2 \\log(x)^3</span>
<span class="sd">              + \\frac{1}{24} \\ell^3 \\log(x)^4.</span>

<span class="sd">    :param x: a variable to transform.</span>
<span class="sd">    :type x: biogeme.expressions.expr.Expression</span>
<span class="sd">    :param ell: parameter of the transformation.</span>
<span class="sd">    :type ell: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: the Box-Cox transform</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ell</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">Beta</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ell</span><span class="o">.</span><span class="n">ub</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ell</span><span class="o">.</span><span class="n">lb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">warning_msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;It is advised to set the bounds on parameter </span><span class="si">{</span><span class="n">ell</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">. &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;A value of -10 and 10 should be appropriate: Beta(&quot;</span><span class="si">{</span><span class="n">ell</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&quot;, &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">ell</span><span class="o">.</span><span class="n">initValue</span><span class="si">}</span><span class="s1">, -10, 10, </span><span class="si">{</span><span class="n">ell</span><span class="o">.</span><span class="n">status</span><span class="si">}</span><span class="s1">)&#39;</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">warning_msg</span><span class="p">)</span>

    <span class="n">regular</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="n">ell</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">ell</span>
    <span class="n">mclaurin</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">expr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="o">+</span> <span class="n">ell</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="o">+</span> <span class="n">ell</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">/</span> <span class="mf">6.0</span>
        <span class="o">+</span> <span class="n">ell</span><span class="o">**</span><span class="mi">3</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">4</span> <span class="o">/</span> <span class="mf">24.0</span>
    <span class="p">)</span>
    <span class="n">close_to_zero</span> <span class="o">=</span> <span class="p">(</span><span class="n">ell</span> <span class="o">&lt;</span> <span class="n">expr</span><span class="o">.</span><span class="n">Numeric</span><span class="p">(</span><span class="mf">1.0e-5</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">ell</span> <span class="o">&gt;</span> <span class="o">-</span><span class="n">expr</span><span class="o">.</span><span class="n">Numeric</span><span class="p">(</span><span class="mf">1.0e-5</span><span class="p">))</span>
    <span class="n">smooth</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Elem</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="n">regular</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="n">mclaurin</span><span class="p">},</span> <span class="n">close_to_zero</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">Elem</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="n">smooth</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">Numeric</span><span class="p">(</span><span class="mi">0</span><span class="p">)},</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span></div>



<div class="viewcode-block" id="piecewiseVariables">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.piecewiseVariables">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">piecewiseVariables</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">thresholds</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate the variables to include in a piecewise linear specification.</span>

<span class="sd">    If there are K thresholds, K-1 variables are generated. The first</span>
<span class="sd">    and last thresholds can be defined as None, corresponding to</span>
<span class="sd">    :math:`-\\infty` and :math:`+\\infty`,respectively. If :math:`t` is</span>
<span class="sd">    the variable of interest, for each interval :math:`[a:a+b[`, we</span>
<span class="sd">    define a variable defined as:</span>

<span class="sd">    .. math:: x_{Ti} =\\left\\{  \\begin{array}{ll} 0 &amp; \\text{if }</span>
<span class="sd">              t &lt; a \\\\ t-a &amp; \\text{if } a \\leq t &lt; a+b \\\\ b  &amp;</span>
<span class="sd">              \\text{otherwise}  \\end{array}\\right. \\;\\;\\;x_{Ti} =</span>
<span class="sd">              \\max(0, \\min(t-a, b))</span>

<span class="sd">    :param variable: variable for which we need the piecewise linear</span>
<span class="sd">       transform. The expression itself or the name of the variable</span>
<span class="sd">       can be given.</span>
<span class="sd">    :type variable: biogeme.expressions.expr.Expression or str</span>

<span class="sd">    :param thresholds: list of thresholds</span>
<span class="sd">    :type thresholds: list(float)</span>

<span class="sd">    :return: list of variables to for the piecewise linear specification.</span>
<span class="sd">    :rtype: list(biogeme.expressions.expr.Expression)</span>

<span class="sd">    :raise BiogemeError: if the thresholds are not defined properly,</span>
<span class="sd">        as only the first and the last thresholds can be set</span>
<span class="sd">        to None.</span>

<span class="sd">    .. seealso:: :meth:`piecewiseFormula`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">eye</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">thresholds</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">thresholds</span><span class="p">):</span>
        <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;All thresholds for the piecewise linear specification are set to None.&#39;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">BiogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>
    <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">thresholds</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;For piecewise linear specification, only the first and &#39;</span>
            <span class="s1">&#39;the last thresholds can be None&#39;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">BiogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>

    <span class="c1"># If the name of the variable is given, we transform it into an expression.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">variable</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">variable</span><span class="p">)</span>

    <span class="c1"># First variable</span>
    <span class="k">if</span> <span class="n">thresholds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">bioMin</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">thresholds</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">thresholds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">thresholds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">expr</span><span class="o">.</span><span class="n">bioMax</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Numeric</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMin</span><span class="p">(</span><span class="n">variable</span> <span class="o">-</span> <span class="n">thresholds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">))</span>
        <span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">eye</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">results</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="n">expr</span><span class="o">.</span><span class="n">bioMax</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Numeric</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMin</span><span class="p">(</span><span class="n">variable</span> <span class="o">-</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">b</span><span class="p">))</span>
        <span class="p">]</span>

    <span class="c1"># Last variable</span>
    <span class="k">if</span> <span class="n">thresholds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">results</span> <span class="o">+=</span> <span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">bioMax</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">variable</span> <span class="o">-</span> <span class="n">thresholds</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">thresholds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">thresholds</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">results</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="n">expr</span><span class="o">.</span><span class="n">bioMax</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">Numeric</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMin</span><span class="p">(</span><span class="n">variable</span> <span class="o">-</span> <span class="n">thresholds</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="p">))</span>
        <span class="p">]</span>
    <span class="k">return</span> <span class="n">results</span></div>



<div class="viewcode-block" id="piecewiseFormula">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.piecewiseFormula">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">piecewiseFormula</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">thresholds</span><span class="p">,</span> <span class="n">betas</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate the formula for a piecewise linear specification.</span>

<span class="sd">    If there are K thresholds, K-1 variables are generated. The first</span>
<span class="sd">    and last thresholds can be defined as None, corresponding to</span>
<span class="sd">    :math:`-\\infty` and :math:`+\\infty`, respectively. If :math:`t` is</span>
<span class="sd">    the variable of interest, for each interval :math:`[a:a+b[`, we</span>
<span class="sd">    define a variable defined as:</span>

<span class="sd">    .. math:: x_{Ti} =\\left\\{  \\begin{array}{ll} 0 &amp; \\text{if }</span>
<span class="sd">              t &lt; a \\\\ t-a &amp; \\text{if } a \\leq t &lt; a+b \\\\ b  &amp;</span>
<span class="sd">              \\text{otherwise}  \\end{array}\\right. \\;\\;\\;x_{Ti} =</span>
<span class="sd">              \\max(0, \\min(t-a, b))</span>

<span class="sd">    New variables and new parameters are automatically created to</span>
<span class="sd">    obtain the specification</span>

<span class="sd">    .. math:: \\sum_{i=1}^{K-1} \\beta_i x_{Ti}</span>

<span class="sd">    :param variable: name of the variable for which we need the</span>
<span class="sd">        piecewise linear transform.</span>
<span class="sd">    :type variable: string</span>

<span class="sd">    :param thresholds: list of thresholds</span>
<span class="sd">    :type thresholds: list(float)</span>

<span class="sd">    :param betas: list of Beta parameters to be used in the</span>
<span class="sd">        specification.  The number of entries should be the number of</span>
<span class="sd">        thresholds, minus one. If None, for each interval, the</span>
<span class="sd">        parameter Beta(&#39;beta_VAR_interval&#39;,0, None, None, 0) is used,</span>
<span class="sd">        where var is the name of the variable. Default: none.</span>
<span class="sd">    :type betas:</span>
<span class="sd">        list(biogeme.expresssions.Beta)</span>

<span class="sd">    :return: expression of  the piecewise linear specification.</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    :raise BiogemeError: if the thresholds are not defined properly,</span>
<span class="sd">        which means that only the first and the last threshold can be set</span>
<span class="sd">        to None.</span>

<span class="sd">    :raise BiogemeError: if the length of list ``initialexpr.Betas`` is</span>
<span class="sd">        not equal to the length of ``thresholds`` minus one.</span>

<span class="sd">    .. seealso:: :meth:`piecewiseVariables`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">Variable</span><span class="p">):</span>
        <span class="n">the_variable</span> <span class="o">=</span> <span class="n">variable</span>
        <span class="n">the_name</span> <span class="o">=</span> <span class="n">variable</span><span class="o">.</span><span class="n">name</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">the_name</span> <span class="o">=</span> <span class="n">variable</span>
        <span class="n">the_variable</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;The first argument of piecewiseFormula must be the &#39;</span>
            <span class="s1">&#39;name of a variable, or the variable itself..&#39;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">BiogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>

    <span class="n">eye</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">thresholds</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">thresholds</span><span class="p">):</span>
        <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;All thresholds for the piecewise linear specification are set to None.&#39;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">BiogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>
    <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">thresholds</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;For piecewise linear specification, only the first and &#39;</span>
            <span class="s1">&#39;the last thresholds can be None&#39;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">BiogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">betas</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">betas</span><span class="p">)</span> <span class="o">!=</span> <span class="n">eye</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;As there are </span><span class="si">{</span><span class="n">eye</span><span class="si">}</span><span class="s1"> thresholds, a total of </span><span class="si">{</span><span class="n">eye</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s1"> &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;Beta parameters are needed, and not </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">betas</span><span class="p">)</span><span class="si">}</span><span class="s1">.&#39;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">BiogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>

    <span class="n">theVars</span> <span class="o">=</span> <span class="n">piecewiseVariables</span><span class="p">(</span><span class="n">the_variable</span><span class="p">,</span> <span class="n">thresholds</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">betas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">betas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a_threshold</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">thresholds</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">next_threshold</span> <span class="o">=</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">a_name</span> <span class="o">=</span> <span class="s1">&#39;minus_inf&#39;</span> <span class="k">if</span> <span class="n">a_threshold</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">a_threshold</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">next_name</span> <span class="o">=</span> <span class="s1">&#39;inf&#39;</span> <span class="k">if</span> <span class="n">next_threshold</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">next_threshold</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">betas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">Beta</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;beta_</span><span class="si">{</span><span class="n">the_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">a_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">next_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="n">terms</span> <span class="o">=</span> <span class="p">[</span><span class="n">beta</span> <span class="o">*</span> <span class="n">theVars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">beta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">betas</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span></div>



<div class="viewcode-block" id="piecewise_as_variable">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.piecewise_as_variable">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">piecewise_as_variable</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">thresholds</span><span class="p">,</span> <span class="n">betas</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate the formula for a piecewise linear specification, seen</span>
<span class="sd">    as a transformed variable.</span>

<span class="sd">    If there are K thresholds, K-1 variables are generated. The first</span>
<span class="sd">    and last thresholds can be defined as None, corresponding to</span>
<span class="sd">    :math:`-\\infty` and :math:`+\\infty`, respectively. If :math:`t` is</span>
<span class="sd">    the variable of interest, for each interval :math:`[a:a+b[`, we</span>
<span class="sd">    define a variable defined as:</span>

<span class="sd">    .. math:: x_{Ti} =\\left\\{  \\begin{array}{ll} 0 &amp; \\text{if }</span>
<span class="sd">              t &lt; a \\\\ t-a &amp; \\text{if } a \\leq t &lt; a+b \\\\ b  &amp;</span>
<span class="sd">              \\text{otherwise}  \\end{array}\\right. \\;\\;\\;x_{Ti} =</span>
<span class="sd">              \\max(0, \\min(t-a, b))</span>

<span class="sd">    The specification this is returned is</span>

<span class="sd">    .. math:: x_{T1} + \\sum_{i=2}^{K-1} \beta_i x_{Ti}</span>

<span class="sd">    :param variable: name of the variable for which we need the</span>
<span class="sd">        piecewise linear transform.</span>
<span class="sd">    :type variable: string</span>

<span class="sd">    :param thresholds: list of thresholds</span>
<span class="sd">    :type thresholds: list(float)</span>

<span class="sd">    :param betas: list of Beta parameters to be used in the</span>
<span class="sd">        specification.  The number of entries should be the number of</span>
<span class="sd">        thresholds, minus two. If None, for each interval, the</span>
<span class="sd">        parameter Beta(&#39;beta_VAR_interval&#39;,0, None, None, 0) is used,</span>
<span class="sd">        where var is the name of the variable. Default: none.</span>
<span class="sd">    :type betas:</span>
<span class="sd">        list(biogeme.expresssions.Beta)</span>

<span class="sd">    :return: expression of  the piecewise linear specification.</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    :raise BiogemeError: if the thresholds are not defined properly,</span>
<span class="sd">        which means that only the first and the last threshold can be set</span>
<span class="sd">        to None.</span>

<span class="sd">    :raise BiogemeError: if the length of list ``initialexpr.Betas`` is</span>
<span class="sd">        not equal to the length of ``thresholds`` minus one.</span>

<span class="sd">    .. seealso:: :meth:`piecewiseVariables`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">Variable</span><span class="p">):</span>
        <span class="n">the_variable</span> <span class="o">=</span> <span class="n">variable</span>
        <span class="n">the_name</span> <span class="o">=</span> <span class="n">variable</span><span class="o">.</span><span class="n">name</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">the_name</span> <span class="o">=</span> <span class="n">variable</span>
        <span class="n">the_variable</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;The first argument of piecewiseFormula must be the &#39;</span>
            <span class="s1">&#39;name of a variable, or the variable itself..&#39;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">BiogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>

    <span class="n">eye</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">thresholds</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">thresholds</span><span class="p">):</span>
        <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;All thresholds for the piecewise linear specification are set to None.&#39;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">BiogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>
    <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">thresholds</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;For piecewise linear specification, only the first and &#39;</span>
            <span class="s1">&#39;the last thresholds can be None&#39;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">BiogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">betas</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">betas</span><span class="p">)</span> <span class="o">!=</span> <span class="n">eye</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;As there are </span><span class="si">{</span><span class="n">eye</span><span class="si">}</span><span class="s1"> thresholds, a total of </span><span class="si">{</span><span class="n">eye</span><span class="o">-</span><span class="mi">2</span><span class="si">}</span><span class="s1"> &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;Beta parameters are needed, and not </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">betas</span><span class="p">)</span><span class="si">}</span><span class="s1">.&#39;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">BiogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>

    <span class="n">theVars</span> <span class="o">=</span> <span class="n">piecewiseVariables</span><span class="p">(</span><span class="n">the_variable</span><span class="p">,</span> <span class="n">thresholds</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">betas</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">betas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a_threshold</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">thresholds</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">next_threshold</span> <span class="o">=</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">a_name</span> <span class="o">=</span> <span class="s1">&#39;minus_inf&#39;</span> <span class="k">if</span> <span class="n">a_threshold</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">a_threshold</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">next_name</span> <span class="o">=</span> <span class="s1">&#39;inf&#39;</span> <span class="k">if</span> <span class="n">next_threshold</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">next_threshold</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">betas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">Beta</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;beta_</span><span class="si">{</span><span class="n">the_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">a_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">next_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="n">terms</span> <span class="o">=</span> <span class="p">[</span><span class="n">beta</span> <span class="o">*</span> <span class="n">theVars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">beta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">betas</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">theVars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span></div>



<div class="viewcode-block" id="piecewiseFunction">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.piecewiseFunction">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">piecewiseFunction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">thresholds</span><span class="p">,</span> <span class="n">betas</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Plot a piecewise linear specification.</span>

<span class="sd">    If there are K thresholds, K-1 variables are generated. The first</span>
<span class="sd">    and last thresholds can be defined as None, corresponding to</span>
<span class="sd">    :math:`-\\infty` and :math:`+\\infty`, respectively. If :math:`t` is</span>
<span class="sd">    the variable of interest, for each interval :math:`[a:a+b[`, we</span>
<span class="sd">    define a variable defined as:</span>

<span class="sd">    .. math:: x_{Ti} =\\left\\{  \\begin{array}{ll} 0 &amp; \\text{if }</span>
<span class="sd">              t &lt; a \\\\ t-a &amp; \\text{if } a \\leq t &lt; a+b \\\\ b  &amp;</span>
<span class="sd">              \\text{otherwise}  \\end{array}\\right. \\;\\;\\;x_{Ti} =</span>
<span class="sd">              \\max(0, \\min(t-a, b))</span>

<span class="sd">    :param x: value at which the piecewise specification must be avaluated</span>
<span class="sd">    :type x: float</span>

<span class="sd">    :param thresholds: list of thresholds</span>
<span class="sd">    :type thresholds: list(float)</span>

<span class="sd">    :param betas: list of the Beta parameters.  The number of entries</span>
<span class="sd">                         should be the number of thresholds, plus</span>
<span class="sd">                         one.</span>
<span class="sd">    :type betas: list(float)</span>

<span class="sd">    :return: value of the numpy function</span>
<span class="sd">    :rtype: float</span>

<span class="sd">    :raise BiogemeError: if the thresholds are not defined properly,</span>
<span class="sd">        which means that only the first and the last threshold can be set</span>
<span class="sd">        to None.</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">eye</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">thresholds</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">thresholds</span><span class="p">):</span>
        <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;All thresholds for the piecewise linear specification &#39;</span> <span class="s1">&#39;are set to None.&#39;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">BiogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>
    <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">thresholds</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;For piecewise linear specification, only the first and &#39;</span>
            <span class="s1">&#39;the last thresholds can be None&#39;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">BiogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">betas</span><span class="p">)</span> <span class="o">!=</span> <span class="n">eye</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">errorMsg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;As there are </span><span class="si">{</span><span class="n">eye</span><span class="si">}</span><span class="s1"> thresholds, a total of </span><span class="si">{</span><span class="n">eye</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s1"> values &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;are needed to initialize the parameters. But &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">betas</span><span class="p">)</span><span class="si">}</span><span class="s1"> are provided&#39;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">BiogemeError</span><span class="p">(</span><span class="n">errorMsg</span><span class="p">)</span>

    <span class="c1"># If the first threshold is not -infinity, we need to check if</span>
    <span class="c1"># x is beyond it.</span>
    <span class="k">if</span> <span class="n">thresholds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">thresholds</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="mi">0</span>
    <span class="n">rest</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">betas</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">v</span> <span class="o">*</span> <span class="n">rest</span>
            <span class="k">return</span> <span class="n">total</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">v</span> <span class="o">*</span> <span class="n">rest</span>
            <span class="k">return</span> <span class="n">total</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">v</span> <span class="o">*</span> <span class="p">(</span>
            <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="mi">0</span> <span class="k">if</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">rest</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">thresholds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">total</span></div>



<div class="viewcode-block" id="logmev">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.logmev">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">logmev</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">logGi</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">choice</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Log of the choice probability for a MEV model.</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>

<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param logGi: a dictionary mapping each alternative id with the function</span>

<span class="sd">        .. math:: \\ln \\frac{\\partial G}{\\partial y_i}</span>
<span class="sd">            (e^{V_1},\\ldots,e^{V_J})</span>

<span class="sd">        where :math:`G` is the MEV generating function. If an alternative</span>
<span class="sd">        :math:`i` is not available, then :math:`G_i = 0`.</span>

<span class="sd">    :type logGi: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param av: dict of objects representing the availability of each</span>
<span class="sd">               alternative (:math:`a_i` in the above formula), indexed</span>
<span class="sd">               by numerical ids. Must be consistent with util, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type av: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: log of the choice probability of the MEV model, given by</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    .. math:: V_i + \\ln G_i(e^{V_1},\\ldots,e^{V_J}) -</span>
<span class="sd">              \\ln\\left(\\sum_j e^{V_j + \\ln G_j(e^{V_1},</span>
<span class="sd">              \\ldots,e^{V_J})}\\right)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">H</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">v</span> <span class="o">+</span> <span class="n">logGi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">V</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">if</span> <span class="n">av</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logP</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">_bioLogLogitFullChoiceSet</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">av</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">choice</span><span class="o">=</span><span class="n">choice</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logP</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">_bioLogLogit</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">choice</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">logP</span></div>



<div class="viewcode-block" id="mev">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.mev">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mev</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">logGi</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">choice</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Choice probability for a MEV model.</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>

<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>


<span class="sd">    :param logGi: a dictionary mapping each alternative id with the function</span>

<span class="sd">        .. math:: \\ln \\frac{\\partial G}{\\partial y_i}</span>
<span class="sd">              (e^{V_1}, \\ldots, e^{V_J})</span>

<span class="sd">        where :math:`G` is the MEV generating function. If an alternative</span>
<span class="sd">        :math:`i` is not available, then :math:`G_i = 0`.</span>

<span class="sd">    :type logGi: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param av: dict of objects representing the availability of each</span>
<span class="sd">               alternative (:math:`a_i` in the above formula), indexed</span>
<span class="sd">               by numerical ids. Must be consistent with util, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type av: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: Choice probability of the MEV model, given by</span>

<span class="sd">    .. math:: \\frac{e^{V_i + \\ln G_i(e^{V_1},</span>
<span class="sd">              \\ldots,e^{V_J})}}{\\sum_j e^{V_j +</span>
<span class="sd">              \\ln G_j(e^{V_1},\\ldots,e^{V_J})}}</span>

<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logmev</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">logGi</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">choice</span><span class="p">))</span></div>



<div class="viewcode-block" id="logmev_endogenousSampling">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.logmev_endogenousSampling">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">logmev_endogenousSampling</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">logGi</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">correction</span><span class="p">,</span> <span class="n">choice</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Log of choice probability for a MEV model, including the</span>
<span class="sd">    correction for endogenous sampling as proposed by `Bierlaire, Bolduc</span>
<span class="sd">    and McFadden (2008)`_.</span>

<span class="sd">    .. _`Bierlaire, Bolduc and McFadden (2008)`:</span>
<span class="sd">       http://dx.doi.org/10.1016/j.trb.2007.09.003</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>

<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param logGi: a dictionary mapping each alternative id with the function</span>

<span class="sd">        .. math:: \\ln \\frac{\\partial G}{\\partial y_i}</span>
<span class="sd">                  (e^{V_1}, \\ldots, e^{V_J})</span>

<span class="sd">        where :math:`G` is the MEV generating function. If an alternative</span>
<span class="sd">        :math:`i` is not available, then :math:`G_i = 0`.</span>

<span class="sd">    :type logGi: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param av: dict of objects representing the availability of each</span>
<span class="sd">               alternative (:math:`a_i` in the above formula), indexed</span>
<span class="sd">               by numerical ids. Must be consistent with util, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type av: dict(int:biogeme.expressions.expr.Expression)</span>


<span class="sd">    :param correction: a dict of expressions for the correstion terms</span>
<span class="sd">                       of each alternative.</span>
<span class="sd">    :type correction: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: log of the choice probability of the MEV model, given by</span>

<span class="sd">    .. math:: V_i + \\ln G_i(e^{V_1}, \\ldots,e^{V_J}) + \\omega_i -</span>
<span class="sd">              \\ln\\left(\\sum_j e^{V_j +</span>
<span class="sd">              \\ln G_j(e^{V_1}, \\ldots, e^{V_J})+ \\omega_j}\\right)</span>

<span class="sd">    where :math:`\\omega_i` is the correction term for alternative :math:`i`.</span>

<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">H</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">v</span> <span class="o">+</span> <span class="n">logGi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">correction</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">V</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">logP</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">_bioLogLogit</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">choice</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">logP</span></div>



<div class="viewcode-block" id="mev_endogenousSampling">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.mev_endogenousSampling">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mev_endogenousSampling</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">logGi</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">correction</span><span class="p">,</span> <span class="n">choice</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Choice probability for a MEV model, including the correction</span>
<span class="sd">    for endogenous sampling as proposed by</span>
<span class="sd">    `Bierlaire, Bolduc and McFadden (2008)`_.</span>

<span class="sd">    .. _`Bierlaire, Bolduc and McFadden (2008)`:</span>
<span class="sd">           http://dx.doi.org/10.1016/j.trb.2007.09.003</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>

<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param logGi: a dictionary mapping each alternative id with the function</span>

<span class="sd">        .. math:: \\ln \\frac{\\partial G}{\\partial y_i}</span>
<span class="sd">              (e^{V_1}, \\ldots, e^{V_J})</span>

<span class="sd">        where :math:`G` is the MEV generating function. If an alternative</span>
<span class="sd">        :math:`i` is not available, then :math:`G_i = 0`.</span>

<span class="sd">    :type logGi: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param av: dict of objects representing the availability of each</span>
<span class="sd">               alternative (:math:`a_i` in the above formula), indexed</span>
<span class="sd">               by numerical ids. Must be consistent with util, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type av: dict(int:biogeme.expressions.expr.Expression)</span>


<span class="sd">    :param correction: a dict of expressions for the correstion terms</span>
<span class="sd">                       of each alternative.</span>
<span class="sd">    :type correction: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: log of the choice probability of the MEV model, given by</span>

<span class="sd">    .. math:: V_i + \\ln G_i(e^{V_1}, \\ldots, e^{V_J}) + \\omega_i -</span>
<span class="sd">              \\ln\\left(\\sum_j e^{V_j + \\ln G_j(e^{V_1},\\ldots,e^{V_J})+</span>
<span class="sd">              \\omega_j}\\right)</span>

<span class="sd">    where :math:`\\omega_i` is the correction term for alternative :math:`i`.</span>

<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logmev_endogenousSampling</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">logGi</span><span class="p">,</span> <span class="n">av</span><span class="p">,</span> <span class="n">correction</span><span class="p">,</span> <span class="n">choice</span><span class="p">))</span></div>



<div class="viewcode-block" id="getMevGeneratingForNested">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.getMevGeneratingForNested">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">getMevGeneratingForNested</span><span class="p">(</span>
    <span class="n">V</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span> <span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">],</span>
    <span class="n">availability</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span> <span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">],</span>
    <span class="n">nests</span><span class="p">:</span> <span class="n">NestsForNestedLogit</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implements the  MEV generating function for the nested logit model</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">               alternative, indexed</span>
<span class="sd">               by numerical ids. Must be consistent with util, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :param nests: an object describing the nests</span>

<span class="sd">    :return: a dictionary mapping each alternative id with the function</span>

<span class="sd">    .. math:: G(e^{V_1},</span>
<span class="sd">              \\ldots,e^{V_J}) =  \\sum_m \\left( \\sum_{\\ell \\in C_m}</span>
<span class="sd">              y_\\ell^{\\mu_m}\\right)^{\\frac{\\mu}{\\mu_m}}</span>

<span class="sd">    where :math:`G` is the MEV generating function.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">termsForNests</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">nests</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">availability</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sumdict</span> <span class="o">=</span> <span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">nest_param</span> <span class="o">*</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">list_of_alternatives</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sumdict</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">Elem</span><span class="p">(</span>
                    <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">nest_param</span> <span class="o">*</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">])},</span>
                    <span class="n">availability</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Numeric</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">list_of_alternatives</span>
            <span class="p">]</span>
        <span class="n">theSum</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span><span class="n">sumdict</span><span class="p">)</span>
        <span class="n">termsForNests</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theSum</span><span class="o">**</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">m</span><span class="o">.</span><span class="n">nest_param</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nests</span><span class="o">.</span><span class="n">alone</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nests</span><span class="o">.</span><span class="n">alone</span><span class="p">:</span>
            <span class="n">termsForNests</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span><span class="n">termsForNests</span><span class="p">)</span></div>



<div class="viewcode-block" id="getMevForNested">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.getMevForNested">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">getMevForNested</span><span class="p">(</span>
    <span class="n">V</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span> <span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">],</span>
    <span class="n">availability</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span> <span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">],</span>
    <span class="n">nests</span><span class="p">:</span> <span class="n">NestsForNestedLogit</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span> <span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implements the derivatives of MEV generating function for the</span>
<span class="sd">    nested logit model</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">        each alternative, indexed by numerical ids.</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">               alternative, indexed</span>
<span class="sd">               by numerical ids. Must be consistent with util, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :param nests: object containing the description of the nests.</span>

<span class="sd">    :return: a dictionary mapping each alternative id with the function</span>

<span class="sd">        .. math:: \\ln \\frac{\\partial G}{\\partial y_i}(e^{V_1},</span>
<span class="sd">              \\ldots,e^{V_J}) = e^{(\\mu_m-1)V_i}</span>
<span class="sd">              \\left(\\sum_{i=1}^{J_m} e^{\\mu_m V_i}\\right)^</span>
<span class="sd">              {\\frac{1}{\\mu_m}-1}</span>

<span class="sd">        where :math:`m` is the (only) nest containing alternative :math:`i`,</span>
<span class="sd">        and :math:`G` is the MEV generating function.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">nests</span><span class="o">.</span><span class="n">alone</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logGi</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logGi</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nests</span><span class="o">.</span><span class="n">alone</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">nests</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">availability</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sumdict</span> <span class="o">=</span> <span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">nest_param</span> <span class="o">*</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">list_of_alternatives</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sumdict</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">Elem</span><span class="p">(</span>
                    <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">nest_param</span> <span class="o">*</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">])},</span>
                    <span class="n">availability</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Numeric</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">list_of_alternatives</span>
            <span class="p">]</span>
        <span class="n">theSum</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span><span class="n">sumdict</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">list_of_alternatives</span><span class="p">:</span>
            <span class="n">logGi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">nest_param</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span>
                <span class="mf">1.0</span> <span class="o">/</span> <span class="n">m</span><span class="o">.</span><span class="n">nest_param</span> <span class="o">-</span> <span class="mf">1.0</span>
            <span class="p">)</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">theSum</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">logGi</span></div>



<div class="viewcode-block" id="getMevForNestedMu">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.getMevForNestedMu">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">getMevForNestedMu</span><span class="p">(</span>
    <span class="n">V</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span> <span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">],</span>
    <span class="n">availability</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span> <span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">],</span>
    <span class="n">nests</span><span class="p">:</span> <span class="n">NestsForNestedLogit</span><span class="p">,</span>
    <span class="n">mu</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span> <span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implements the MEV generating function for the nested logit model,</span>
<span class="sd">    including the scale parameter</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">        each alternative, indexed by numerical ids.</span>

<span class="sd">    :param availability: dict of objects representing the availability</span>
<span class="sd">        of each alternative, indexed</span>
<span class="sd">        by numerical ids. Must be consistent with util, or</span>
<span class="sd">        None. In this case, all alternatives are supposed to be</span>
<span class="sd">        always available.</span>

<span class="sd">    :param nests: A tuple containing as many items as nests.</span>
<span class="sd">        Each item is also a tuple containing two items:</span>

<span class="sd">        - an object of type biogeme.expressions. expr.Expression</span>
<span class="sd">          representing the nest parameter,</span>
<span class="sd">        - a list containing the list of identifiers of the alternatives</span>
<span class="sd">          belonging to the nest.</span>

<span class="sd">        Example::</span>

<span class="sd">            nesta = MUA, [1, 2, 3]</span>
<span class="sd">           nestb = MUB, [4, 5, 6]</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :param mu: scale parameter</span>

<span class="sd">    :return: a dictionary mapping each alternative id with the function</span>

<span class="sd">        .. math:: \\frac{\\partial G}{\\partial y_i}(e^{V_1},\\ldots,e^{V_J}) =</span>
<span class="sd">                  \\mu e^{(\\mu_m-1)V_i} \\left(\\sum_{i=1}^{J_m}</span>
<span class="sd">                  e^{\\mu_m V_i}\\right)^{\\frac{\\mu}{\\mu_m}-1}</span>

<span class="sd">        where :math:`m` is the (only) nest containing alternative :math:`i`,</span>
<span class="sd">        and :math:`G` is the MEV generating function.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">nests</span><span class="o">.</span><span class="n">alone</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logGi</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logGi</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">mu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nests</span><span class="o">.</span><span class="n">alone</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">nests</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">availability</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sumdict</span> <span class="o">=</span> <span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">nest_param</span> <span class="o">*</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">list_of_alternatives</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sumdict</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">Elem</span><span class="p">(</span>
                    <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">nest_param</span> <span class="o">*</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">])},</span> <span class="n">availability</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">list_of_alternatives</span>
            <span class="p">]</span>
        <span class="n">theSum</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span><span class="n">sumdict</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">list_of_alternatives</span><span class="p">:</span>
            <span class="n">logGi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
                <span class="o">+</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">nest_param</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="o">+</span> <span class="p">(</span><span class="n">mu</span> <span class="o">/</span> <span class="n">m</span><span class="o">.</span><span class="n">nest_param</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">theSum</span><span class="p">)</span>
            <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">logGi</span><span class="p">)</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">logGi</span></div>



<div class="viewcode-block" id="nested">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.nested">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">nested</span><span class="p">(</span>
    <span class="n">V</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span> <span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">],</span>
    <span class="n">availability</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span> <span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">],</span>
    <span class="n">nests</span><span class="p">:</span> <span class="n">NestsForNestedLogit</span><span class="p">,</span>
    <span class="n">choice</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implements the nested logit model as a MEV model.</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>

<span class="sd">    :param availability: dict of objects representing the availability</span>
<span class="sd">                         of each alternative, indexed by numerical</span>
<span class="sd">                         ids. Must be consistent with util, or None. In</span>
<span class="sd">                         this case, all alternatives are supposed to</span>
<span class="sd">                         be always available.</span>

<span class="sd">    :param nests: object containing the description of the nests.</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>

<span class="sd">    :return: choice probability for the nested logit model,</span>
<span class="sd">             based on the derivatives of the MEV generating function produced</span>
<span class="sd">             by the function getMevForNested</span>

<span class="sd">    :raise BiogemeError: if the definition of the nests is invalid.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ok</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="n">nests</span><span class="o">.</span><span class="n">check_partition</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">BiogemeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="n">logGi</span> <span class="o">=</span> <span class="n">getMevForNested</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">mev</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">logGi</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">choice</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">P</span></div>



<div class="viewcode-block" id="lognested">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.lognested">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">lognested</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">:</span> <span class="n">NestsForNestedLogit</span><span class="p">,</span> <span class="n">choice</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implements the log of a nested logit model as a MEV model.</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">        each alternative, indexed by numerical ids.</span>

<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">        alternative (:math:`a_i` in the above formula), indexed</span>
<span class="sd">        by numerical ids. Must be consistent with util, or</span>
<span class="sd">        None. In this case, all alternatives are supposed to be</span>
<span class="sd">        always available.</span>

<span class="sd">    :type availability: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: A tuple containing as many items as nests.</span>
<span class="sd">        Each item is also a tuple containing two items:</span>

<span class="sd">        - an object of type biogeme.expressions. expr.Expression representing</span>
<span class="sd">          the nest parameter,</span>
<span class="sd">        - a list containing the list of identifiers of the alternatives</span>
<span class="sd">          belonging to the nest.</span>

<span class="sd">        Example::</span>

<span class="sd">            nesta = MUA, [1, 2, 3]</span>
<span class="sd">            nestb = MUB, [4, 5, 6]</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: log of choice probability for the nested logit model,</span>
<span class="sd">             based on the derivatives of the MEV generating function produced</span>
<span class="sd">             by the function getMevForNested</span>

<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    :raise BiogemeError: if the definition of the nests is invalid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nests</span><span class="p">,</span> <span class="n">NestsForNestedLogit</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s1">&#39;It is recommended to define the nests of the nested logit model using &#39;</span>
            <span class="s1">&#39;the objects OneNestForNestedLogit and NestsForNestedLogit defined &#39;</span>
            <span class="s1">&#39;in biogeme.nests.&#39;</span>
        <span class="p">)</span>
        <span class="n">nests</span> <span class="o">=</span> <span class="n">NestsForNestedLogit</span><span class="p">(</span><span class="n">choice_set</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">V</span><span class="p">),</span> <span class="n">tuple_of_nests</span><span class="o">=</span><span class="n">nests</span><span class="p">)</span>

    <span class="n">ok</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="n">nests</span><span class="o">.</span><span class="n">check_partition</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">BiogemeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="n">logGi</span> <span class="o">=</span> <span class="n">getMevForNested</span><span class="p">(</span>
        <span class="n">V</span><span class="p">,</span>
        <span class="n">availability</span><span class="p">,</span>
        <span class="n">nests</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">logP</span> <span class="o">=</span> <span class="n">logmev</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">logGi</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">choice</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">logP</span></div>



<div class="viewcode-block" id="nestedMevMu">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.nestedMevMu">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">nestedMevMu</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implements the nested logit model as a MEV model, where mu is also</span>
<span class="sd">    a parameter, if the user wants to test different normalization</span>
<span class="sd">    schemes.</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>

<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">               alternative (:math:`a_i` in the above formula), indexed</span>
<span class="sd">               by numerical ids. Must be consistent with util, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type availability: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: A tuple containing as many items as nests.</span>
<span class="sd">        Each item is also a tuple containing two items:</span>

<span class="sd">        - an object of type biogeme.expressions.expr.Expression  representing</span>
<span class="sd">          the nest parameter,</span>
<span class="sd">        - a list containing the list of identifiers of the alternatives</span>
<span class="sd">          belonging to the nest.</span>

<span class="sd">        Example::</span>

<span class="sd">            nesta = MUA ,[1, 2, 3]</span>
<span class="sd">            nestb = MUB ,[4, 5, 6]</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :param mu: expression producing the value of the top-level scale parameter.</span>
<span class="sd">    :type mu:  biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: the nested logit choice probability based on the following</span>
<span class="sd">             derivatives of the MEV generating function:</span>

<span class="sd">    .. math:: \\frac{\\partial G}{\\partial y_i}(e^{V_1},\\ldots,e^{V_J}) =</span>
<span class="sd">              \\mu e^{(\\mu_m-1)V_i} \\left(\\sum_{i=1}^{J_m}</span>
<span class="sd">              e^{\\mu_m V_i}\\right)^{\\frac{\\mu}{\\mu_m}-1}</span>

<span class="sd">    Where :math:`m` is the (only) nest containing alternative :math:`i`, and</span>
<span class="sd">    :math:`G` is the MEV generating function.</span>

<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">lognestedMevMu</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">mu</span><span class="p">))</span></div>



<div class="viewcode-block" id="lognestedMevMu">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.lognestedMevMu">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">lognestedMevMu</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implements the log of the nested logit model as a MEV model, where</span>
<span class="sd">    mu is also a parameter, if the user wants to test different</span>
<span class="sd">    normalization schemes.</span>


<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">        each alternative, indexed by numerical ids.</span>

<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">               alternative (:math:`a_i` in the above formula), indexed</span>
<span class="sd">               by numerical ids. Must be consistent with util, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type availability: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: A tuple containing as many items as nests.</span>
<span class="sd">        Each item is also a tuple containing two items:</span>

<span class="sd">        - an object of type biogeme.expressions.expr.Expression  representing</span>
<span class="sd">          the nest parameter,</span>
<span class="sd">        - a list containing the list of identifiers of the alternatives</span>
<span class="sd">          belonging to the nest.</span>

<span class="sd">        Example::</span>

<span class="sd">            nesta = MUA, [1, 2, 3]</span>
<span class="sd">            nestb = MUB, [4, 5, 6]</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :param mu: expression producing the value of the top-level scale parameter.</span>
<span class="sd">    :type mu:  biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: the log of the nested logit choice probability based on the</span>
<span class="sd">        following derivatives of the MEV generating function:</span>

<span class="sd">        .. math:: \\frac{\\partial G}{\\partial y_i}(e^{V_1},\\ldots,e^{V_J}) =</span>
<span class="sd">                  \\mu e^{(\\mu_m-1)V_i} \\left(\\sum_{i=1}^{J_m}</span>
<span class="sd">                  e^{\\mu_m V_i}\\right)^{\\frac{\\mu}{\\mu_m}-1}</span>

<span class="sd">        where :math:`m` is the (only) nest containing alternative :math:`i`,</span>
<span class="sd">        and :math:`G` is the MEV generating function.</span>

<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">logGi</span> <span class="o">=</span> <span class="n">getMevForNestedMu</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
    <span class="n">logP</span> <span class="o">=</span> <span class="n">logmev</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">logGi</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">choice</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">logP</span></div>



<div class="viewcode-block" id="cnl_avail">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.cnl_avail">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cnl_avail</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">sampling_log_probability</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Same as cnl. Maintained for backward compatibility</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>
<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">               alternative, indexed</span>
<span class="sd">               by numerical ids. Must be consistent with util, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type availability: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: a tuple containing as many items as nests. Each item is</span>
<span class="sd">        also a tuple containing two items</span>

<span class="sd">        - an object of type biogeme.expressions.expr.Expression  representing</span>
<span class="sd">          the nest parameter,</span>
<span class="sd">        - a dictionary mapping the alternative ids with the cross-nested</span>
<span class="sd">          parameters for the corresponding nest. If an alternative is</span>
<span class="sd">          missing in the dictionary, the corresponding alpha is set to zero.</span>

<span class="sd">        Example::</span>

<span class="sd">            alphaA = {1: alpha1a,</span>
<span class="sd">                      2: alpha2a,</span>
<span class="sd">                      3: alpha3a,</span>
<span class="sd">                      4: alpha4a,</span>
<span class="sd">                      5: alpha5a,</span>
<span class="sd">                      6: alpha6a}</span>
<span class="sd">            alphaB = {1: alpha1b,</span>
<span class="sd">                      2: alpha2b,</span>
<span class="sd">                      3: alpha3b,</span>
<span class="sd">                      4: alpha4b,</span>
<span class="sd">                      5: alpha5b,</span>
<span class="sd">                      6: alpha6b}</span>
<span class="sd">            nesta = MUA, alphaA</span>
<span class="sd">            nestb = MUB, alphaB</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :param sampling_log_probability: if not None, it means that the</span>
<span class="sd">        choice set is actually a subset that has been sampled from the</span>
<span class="sd">        full choice set. In that case, this is a dictionary mapping</span>
<span class="sd">        each alternative with the logarithm of its probability to be</span>
<span class="sd">        selected in the sample.</span>
<span class="sd">    :type sampling_log_probability: dict(int: biogeme.expressions.Expression)</span>

<span class="sd">    :return: choice probability for the cross-nested logit model.</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cnl</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">sampling_log_probability</span><span class="p">)</span></div>



<div class="viewcode-block" id="cnl">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.cnl">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cnl</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">sampling_log_probability</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implements the cross-nested logit model as a MEV model.</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>
<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">               alternative, indexed</span>
<span class="sd">               by numerical ids. Must be consistent with util, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type availability: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: a tuple containing as many items as nests.</span>
<span class="sd">        Each item is also a tuple containing two items:</span>

<span class="sd">        - an object of type biogeme.expressions. expr.Expression</span>
<span class="sd">          representing the nest parameter,</span>
<span class="sd">        - a dictionary mapping the alternative ids with the cross-nested</span>
<span class="sd">          parameters for the corresponding nest. If an alternative is</span>
<span class="sd">          missing in the dictionary, the corresponding alpha is set to zero.</span>

<span class="sd">        Example::</span>

<span class="sd">            alphaA = {1: alpha1a,</span>
<span class="sd">                      2: alpha2a,</span>
<span class="sd">                      3: alpha3a,</span>
<span class="sd">                      4: alpha4a,</span>
<span class="sd">                      5: alpha5a,</span>
<span class="sd">                      6: alpha6a}</span>
<span class="sd">            alphaB = {1: alpha1b,</span>
<span class="sd">                      2: alpha2b,</span>
<span class="sd">                      3: alpha3b,</span>
<span class="sd">                      4: alpha4b,</span>
<span class="sd">                      5: alpha5b,</span>
<span class="sd">                      6: alpha6b}</span>
<span class="sd">            nesta = MUA, alphaA</span>
<span class="sd">            nestb = MUB, alphaB</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :param sampling_log_probability: if not None, it means that the</span>
<span class="sd">        choice set is actually a subset that has been sampled from the</span>
<span class="sd">        full choice set. In that case, this is a dictionary mapping</span>
<span class="sd">        each alternative with the logarithm of its probability to be</span>
<span class="sd">        selected in the sample.</span>
<span class="sd">    :type sampling_log_probability: dict(int: biogeme.expressions.Expression)</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: choice probability for the cross-nested logit model.</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logcnl</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">sampling_log_probability</span><span class="p">))</span></div>



<div class="viewcode-block" id="logcnl_avail">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.logcnl_avail">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">logcnl_avail</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">sampling_log_probability</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Same as logcnl. Maintained for backward compatibility</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>
<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">               alternative, indexed</span>
<span class="sd">               by numerical ids. Must be consistent with util, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type availability: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: a tuple containing as many items as nests.</span>
<span class="sd">        Each item is also a tuple containing two items:</span>

<span class="sd">        - an object of type biogeme.expressions. expr.Expression</span>
<span class="sd">          representing the nest parameter,</span>
<span class="sd">        - a dictionary mapping the alternative ids with the cross-nested</span>
<span class="sd">          parameters for the corresponding nest. If an alternative is</span>
<span class="sd">          missing in the dictionary, the corresponding alpha is set to zero.</span>

<span class="sd">        Example::</span>

<span class="sd">            alphaA = {1: alpha1a,</span>
<span class="sd">                      2: alpha2a,</span>
<span class="sd">                      3: alpha3a,</span>
<span class="sd">                      4: alpha4a,</span>
<span class="sd">                      5: alpha5a,</span>
<span class="sd">                      6: alpha6a}</span>
<span class="sd">            alphaB = {1: alpha1b,</span>
<span class="sd">                      2: alpha2b,</span>
<span class="sd">                      3: alpha3b,</span>
<span class="sd">                      4: alpha4b,</span>
<span class="sd">                      5: alpha5b,</span>
<span class="sd">                      6: alpha6b}</span>
<span class="sd">            nesta = MUA, alphaA</span>
<span class="sd">            nestb = MUB, alphaB</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :param sampling_log_probability: if not None, it means that the</span>
<span class="sd">        choice set is actually a subset that has been sampled from the</span>
<span class="sd">        full choice set. In that case, this is a dictionary mapping</span>
<span class="sd">        each alternative with the logarithm of its probability to be</span>
<span class="sd">        selected in the sample.</span>
<span class="sd">    :type sampling_log_probability: dict(int: biogeme.expressions.Expression)</span>

<span class="sd">    :return: log of choice probability for the cross-nested logit model.</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">logcnl</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">sampling_log_probability</span><span class="p">)</span></div>



<div class="viewcode-block" id="getMevForCrossNested">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.getMevForCrossNested">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">getMevForCrossNested</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">sampling_log_probability</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implements the MEV generating function for the cross nested logit</span>
<span class="sd">    model as a MEV model.</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>
<span class="sd">    :type V: dict(int: biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">        alternative, indexed</span>
<span class="sd">        by numerical ids. Must be consistent with util, or</span>
<span class="sd">        None. In this case, all alternatives are supposed to be</span>
<span class="sd">        always available.</span>

<span class="sd">    :type availability: dict(int: biogeme.expressions.Expression)</span>

<span class="sd">    :param nests: a tuple containing as many items as nests.</span>
<span class="sd">        Each item is also a tuple containing two items:</span>

<span class="sd">        - an object of type biogeme.expressions. expr.Expression</span>
<span class="sd">          representing the nest parameter,</span>
<span class="sd">        - a dictionary mapping the alternative ids with the cross-nested</span>
<span class="sd">          parameters for the corresponding nest. If an alternative is</span>
<span class="sd">          missing in the dictionary, the corresponding alpha is set to zero.</span>

<span class="sd">        Example::</span>

<span class="sd">            alphaA = {1: alpha1a,</span>
<span class="sd">                      2: alpha2a,</span>
<span class="sd">                      3: alpha3a,</span>
<span class="sd">                      4: alpha4a,</span>
<span class="sd">                      5: alpha5a,</span>
<span class="sd">                      6: alpha6a}</span>
<span class="sd">            alphaB = {1: alpha1b,</span>
<span class="sd">                      2: alpha2b,</span>
<span class="sd">                      3: alpha3b,</span>
<span class="sd">                      4: alpha4b,</span>
<span class="sd">                      5: alpha5b,</span>
<span class="sd">                      6: alpha6b}</span>
<span class="sd">            nesta = MUA, alphaA</span>
<span class="sd">            nestb = MUB, alphaB</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :param sampling_log_probability: if not None, it means that the</span>
<span class="sd">        choice set is actually a subset that has been sampled from the</span>
<span class="sd">        full choice set. In that case, this is a dictionary mapping</span>
<span class="sd">        each alternative with the logarithm of its probability to be</span>
<span class="sd">        selected in the sample.</span>
<span class="sd">    :type sampling_log_probability: dict(int: biogeme.expressions.Expression)</span>

<span class="sd">    :return: log of the choice probability for the cross-nested logit model.</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Gi_terms</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">nests</span><span class="o">.</span><span class="n">alone</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logGi</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">V</span><span class="p">:</span>
            <span class="n">Gi_terms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logGi</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nests</span><span class="o">.</span><span class="n">alone</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nests</span><span class="o">.</span><span class="n">alone</span><span class="p">)):</span>
            <span class="n">Gi_terms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">biosum</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">nests</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">availability</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sampling_log_probability</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">biosum</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">a</span> <span class="o">**</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">biosum</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">sampling_log_probability</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="o">*</span> <span class="n">a</span> <span class="o">**</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="p">]</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sampling_log_probability</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">biosum</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">availability</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span> <span class="o">**</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">biosum</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">sampling_log_probability</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="o">*</span> <span class="n">availability</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="o">*</span> <span class="n">a</span> <span class="o">**</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="p">]</span>
                <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">Gi_terms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="n">a</span> <span class="o">**</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="o">*</span> <span class="n">biosum</span> <span class="o">**</span> <span class="p">((</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="p">]</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">G</span> <span class="ow">in</span> <span class="n">Gi_terms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">logGi</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">Elem</span><span class="p">(</span>
            <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span><span class="n">G</span><span class="p">))},</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">sampling_log_probability</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logGi</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-=</span> <span class="n">sampling_log_probability</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">logGi</span></div>



<div class="viewcode-block" id="logcnl">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.logcnl">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">logcnl</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">sampling_log_probability</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implements the log of the cross-nested logit model as a MEV model.</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>
<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">               alternative, indexed</span>
<span class="sd">               by numerical ids. Must be consistent with util, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type availability: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: a tuple containing as many items as nests.</span>
<span class="sd">        Each item is also a tuple containing two items:</span>

<span class="sd">        - an object of type biogeme.expressions. expr.Expression</span>
<span class="sd">          representing the nest parameter,</span>
<span class="sd">        - a dictionary mapping the alternative ids with the cross-nested</span>
<span class="sd">          parameters for the corresponding nest. If an alternative is</span>
<span class="sd">          missing in the dictionary, the corresponding alpha is set to zero.</span>

<span class="sd">        Example::</span>

<span class="sd">            alphaA = {1: alpha1a,</span>
<span class="sd">                      2: alpha2a,</span>
<span class="sd">                      3: alpha3a,</span>
<span class="sd">                      4: alpha4a,</span>
<span class="sd">                      5: alpha5a,</span>
<span class="sd">                      6: alpha6a}</span>
<span class="sd">            alphaB = {1: alpha1b,</span>
<span class="sd">                      2: alpha2b,</span>
<span class="sd">                      3: alpha3b,</span>
<span class="sd">                      4: alpha4b,</span>
<span class="sd">                      5: alpha5b,</span>
<span class="sd">                      6: alpha6b}</span>
<span class="sd">            nesta = MUA , alphaA</span>
<span class="sd">            nestb = MUB , alphaB</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :param sampling_log_probability: if not None, it means that the</span>
<span class="sd">        choice set is actually a subset that has been sampled from the</span>
<span class="sd">        full choice set. In that case, this is a dictionary mapping</span>
<span class="sd">        each alternative with the logarithm of its probability to be</span>
<span class="sd">        selected in the sample.</span>
<span class="sd">    :type sampling_log_probability: dict(int: biogeme.expressions.Expression)</span>

<span class="sd">    :return: log of the choice probability for the cross-nested logit model.</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    :raise BiogemeError: if the definition of the nests is invalid.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ok</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="n">nests</span><span class="o">.</span><span class="n">check_validity</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">BiogemeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">message</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;CNL: </span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">logGi</span> <span class="o">=</span> <span class="n">getMevForCrossNested</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">sampling_log_probability</span><span class="p">)</span>
    <span class="n">logP</span> <span class="o">=</span> <span class="n">logmev</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">logGi</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">choice</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">logP</span></div>



<div class="viewcode-block" id="cnlmu">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.cnlmu">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cnlmu</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implements the cross-nested logit model as a MEV model with</span>
<span class="sd">    the homogeneity parameters is explicitly involved</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>
<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">               alternative, indexed</span>
<span class="sd">               by numerical ids. Must be consistent with util, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type availability: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: a tuple containing as many items as nests. Each</span>
<span class="sd">        item is also a tuple containing two items:</span>

<span class="sd">        - an object of type biogeme.expressions. expr.Expression representing</span>
<span class="sd">          the nest parameter,</span>
<span class="sd">        - a dictionary mapping the alternative ids with the cross-nested</span>
<span class="sd">          parameters for the corresponding nest. If an alternative is</span>
<span class="sd">          missing in the dictionary, the corresponding alpha is set to zero.</span>

<span class="sd">        Example::</span>

<span class="sd">            alphaA = {1: alpha1a,</span>
<span class="sd">                      2: alpha2a,</span>
<span class="sd">                      3: alpha3a,</span>
<span class="sd">                      4: alpha4a,</span>
<span class="sd">                      5: alpha5a,</span>
<span class="sd">                      6: alpha6a}</span>
<span class="sd">            alphaB = {1: alpha1b,</span>
<span class="sd">                      2: alpha2b,</span>
<span class="sd">                      3: alpha3b,</span>
<span class="sd">                      4: alpha4b,</span>
<span class="sd">                      5: alpha5b,</span>
<span class="sd">                      6: alpha6b}</span>
<span class="sd">            nesta = MUA, alphaA</span>
<span class="sd">            nestb = MUB, alphaB</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :param mu: Homogeneity parameter :math:`\\mu`.</span>
<span class="sd">    :type mu: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: choice probability for the cross-nested logit model.</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">logcnlmu</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">mu</span><span class="p">))</span></div>



<div class="viewcode-block" id="getMevForCrossNestedMu">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.getMevForCrossNestedMu">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">getMevForCrossNestedMu</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implements the MEV generating function for the cross-nested logit</span>
<span class="sd">    model as a MEV model with the homogeneity parameters is explicitly</span>
<span class="sd">    involved.</span>

<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>
<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">               alternative, indexed</span>
<span class="sd">               by numerical ids. Must be consistent with util, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type availability: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: a tuple containing as many items as nests.</span>
<span class="sd">        Each item is also a tuple containing two items:</span>

<span class="sd">        - an object of type biogeme.expressions. expr.Expression representing</span>
<span class="sd">          the nest parameter,</span>
<span class="sd">        - a dictionary mapping the alternative ids with the cross-nested</span>
<span class="sd">          parameters for the corresponding nest. If an alternative is</span>
<span class="sd">          missing in the dictionary, the corresponding alpha is set to zero.</span>

<span class="sd">        Example::</span>

<span class="sd">            alphaA = {1: alpha1a,</span>
<span class="sd">                      2: alpha2a,</span>
<span class="sd">                      3: alpha3a,</span>
<span class="sd">                      4: alpha4a,</span>
<span class="sd">                      5: alpha5a,</span>
<span class="sd">                      6: alpha6a}</span>
<span class="sd">            alphaB = {1: alpha1b,</span>
<span class="sd">                      2: alpha2b,</span>
<span class="sd">                      3: alpha3b,</span>
<span class="sd">                      4: alpha4b,</span>
<span class="sd">                      5: alpha5b,</span>
<span class="sd">                      6: alpha6b}</span>
<span class="sd">            nesta = MUA, alphaA</span>
<span class="sd">            nestb = MUB, alphaB</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :param mu: Homogeneity parameter :math:`\\mu`.</span>
<span class="sd">    :type mu: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: log of the choice probability for the cross-nested logit model.</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Gi_terms</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">nests</span><span class="o">.</span><span class="n">alone</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logGi</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">V</span><span class="p">:</span>
            <span class="n">Gi_terms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logGi</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">mu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nests</span><span class="o">.</span><span class="n">alone</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">nests</span><span class="o">.</span><span class="n">alone</span><span class="p">)):</span>
            <span class="n">Gi_terms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">biosum</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">nests</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">availability</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">biosum</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span>
                <span class="p">[</span><span class="n">a</span> <span class="o">**</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">mu</span><span class="p">)</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">biosum</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">availability</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span> <span class="o">**</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">mu</span><span class="p">)</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">]</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">Gi_terms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="n">a</span> <span class="o">**</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">mu</span><span class="p">)</span>
                <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">exp</span><span class="p">((</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="o">*</span> <span class="n">biosum</span> <span class="o">**</span> <span class="p">((</span><span class="n">mu</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="p">]</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">G</span> <span class="ow">in</span> <span class="n">Gi_terms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">logGi</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">mu</span> <span class="o">*</span> <span class="n">expr</span><span class="o">.</span><span class="n">bioMultSum</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">logGi</span></div>



<div class="viewcode-block" id="logcnlmu">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.logcnlmu">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">logcnlmu</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implements the log of the cross-nested logit model as a MEV model</span>
<span class="sd">    with the homogeneity parameters is explicitly involved.</span>


<span class="sd">    :param V: dict of objects representing the utility functions of</span>
<span class="sd">              each alternative, indexed by numerical ids.</span>
<span class="sd">    :type V: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param availability: dict of objects representing the availability of each</span>
<span class="sd">               alternative, indexed</span>
<span class="sd">               by numerical ids. Must be consistent with util, or</span>
<span class="sd">               None. In this case, all alternatives are supposed to be</span>
<span class="sd">               always available.</span>

<span class="sd">    :type availability: dict(int:biogeme.expressions.expr.Expression)</span>

<span class="sd">    :param nests: a tuple containing as many items as nests. Each item is</span>
<span class="sd">        also a tuple containing two items</span>

<span class="sd">        - an object of type biogeme.expressions. expr.Expression representing</span>
<span class="sd">          the nest parameter,</span>
<span class="sd">        - a dictionary mapping the alternative ids with the cross-nested</span>
<span class="sd">          parameters for the corresponding nest. If an alternative is</span>
<span class="sd">          missing in the dictionary, the corresponding alpha is set to zero.</span>

<span class="sd">        Example::</span>

<span class="sd">            alphaA = {1: alpha1a,</span>
<span class="sd">                      2: alpha2a,</span>
<span class="sd">                      3: alpha3a,</span>
<span class="sd">                      4: alpha4a,</span>
<span class="sd">                      5: alpha5a,</span>
<span class="sd">                      6: alpha6a}</span>
<span class="sd">            alphaB = {1: alpha1b,</span>
<span class="sd">                      2: alpha2b,</span>
<span class="sd">                      3: alpha3b,</span>
<span class="sd">                      4: alpha4b,</span>
<span class="sd">                      5: alpha5b,</span>
<span class="sd">                      6: alpha6b}</span>
<span class="sd">            nesta = MUA , alphaA</span>
<span class="sd">            nestb = MUB , alphaB</span>
<span class="sd">            nests = nesta, nestb</span>

<span class="sd">    :type nests: tuple</span>

<span class="sd">    :param choice: id of the alternative for which the probability must be</span>
<span class="sd">              calculated.</span>
<span class="sd">    :type choice: biogeme.expressions.expr.Expression</span>

<span class="sd">    :param mu: Homogeneity parameter :math:`\\mu`.</span>
<span class="sd">    :type mu: biogeme.expressions.expr.Expression</span>

<span class="sd">    :return: log of the choice probability for the cross-nested logit model.</span>
<span class="sd">    :rtype: biogeme.expressions.expr.Expression</span>

<span class="sd">    :raise BiogemeError: if the definition of the nests is invalid.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ok</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="n">nests</span><span class="o">.</span><span class="n">check_validity</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ok</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">BiogemeError</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="n">logGi</span> <span class="o">=</span> <span class="n">getMevForCrossNestedMu</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">nests</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
    <span class="n">logP</span> <span class="o">=</span> <span class="n">logmev</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">logGi</span><span class="p">,</span> <span class="n">availability</span><span class="p">,</span> <span class="n">choice</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">logP</span></div>



<div class="viewcode-block" id="ordered_likelihood">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.ordered_likelihood">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ordered_likelihood</span><span class="p">(</span><span class="n">continuous_value</span><span class="p">,</span> <span class="n">list_of_discrete_values</span><span class="p">,</span> <span class="n">tau_parameter</span><span class="p">,</span> <span class="n">cdf</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ordered model that maps a continuous quantity with a list of</span>
<span class="sd">        discrete intervals (often logit or probit)</span>

<span class="sd">    Example: discrete values = [1, 2, 3, 4]</span>

<span class="sd">    We define thresholds tau_1_2, tau_2_3 and tau_3_4.</span>
<span class="sd">    In order to impose that the threshold are sorted, we actually define</span>
<span class="sd">        tau_1_2 = tau_parameter</span>
<span class="sd">        tau_2_3 = tau_1_2 + diff2</span>
<span class="sd">        tau_3_4 = tau_2_3 + diff3</span>

<span class="sd">    The probability that the discrete value is 2, say, is the</span>
<span class="sd">    probability that the continuous value lies between tau_1_2 and</span>
<span class="sd">    tau_2_3, where the probability distribution is logistic.</span>

<span class="sd">    :param continuous_value: continuous quantity to mapping</span>
<span class="sd">    :type continuous_value: biogeme.expressions.Expression</span>

<span class="sd">    :param list_of_discrete_values: discrete values</span>
<span class="sd">    :type list_of_discrete_values: list(int)</span>

<span class="sd">    :param tau_parameter: parameter for the first threshold</span>
<span class="sd">    :type tau_parameter: biogeme.expressions.Beta</span>

<span class="sd">    :param cdf: function calculating the CDF of the random variable</span>
<span class="sd">    :type cdf: fct(float) -&gt; float</span>

<span class="sd">    :return: dict where the keys are the discrete values and the</span>
<span class="sd">        values are the corresponding probability.</span>
<span class="sd">    :rtype: dict(int: biogeme.expressions.Expression)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tau_parameter</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">Beta</span><span class="p">):</span>
        <span class="n">error_msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;tau_parameter must be a Beta expression, and not a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">tau_parameter</span><span class="p">)</span><span class="si">}</span><span class="s1">.&#39;</span>
        <span class="p">)</span>
        <span class="k">raise</span> <span class="n">excep</span><span class="o">.</span><span class="n">BiogemeError</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_of_discrete_values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">the_proba</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">list_of_discrete_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">cdf</span><span class="p">(</span><span class="n">continuous_value</span> <span class="o">-</span> <span class="n">tau_parameter</span><span class="p">),</span>
            <span class="n">list_of_discrete_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">cdf</span><span class="p">(</span><span class="n">continuous_value</span> <span class="o">-</span> <span class="n">tau_parameter</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">the_proba</span>

    <span class="n">diffs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">current_item</span><span class="p">:</span> <span class="n">expr</span><span class="o">.</span><span class="n">Beta</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">tau_parameter</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_diff_</span><span class="si">{</span><span class="n">current_item</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="mi">1</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="kc">None</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">current_item</span> <span class="ow">in</span> <span class="n">list_of_discrete_values</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="c1"># First term</span>
    <span class="n">the_proba</span> <span class="o">=</span> <span class="p">{</span><span class="n">list_of_discrete_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">cdf</span><span class="p">(</span><span class="n">continuous_value</span> <span class="o">-</span> <span class="n">tau_parameter</span><span class="p">)}</span>

    <span class="c1"># Intermediate terms</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="n">tau_parameter</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_of_discrete_values</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">next_tau</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">+</span> <span class="n">diffs</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
        <span class="n">the_proba</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">cdf</span><span class="p">(</span><span class="n">continuous_value</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span> <span class="o">-</span> <span class="n">cdf</span><span class="p">(</span><span class="n">continuous_value</span> <span class="o">-</span> <span class="n">next_tau</span><span class="p">)</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="n">next_tau</span>

    <span class="c1"># Last term</span>
    <span class="n">the_proba</span><span class="p">[</span><span class="n">list_of_discrete_values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">cdf</span><span class="p">(</span><span class="n">continuous_value</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">the_proba</span></div>



<div class="viewcode-block" id="ordered_logit">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.ordered_logit">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ordered_logit</span><span class="p">(</span><span class="n">continuous_value</span><span class="p">,</span> <span class="n">list_of_discrete_values</span><span class="p">,</span> <span class="n">tau_parameter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ordered logit model that maps a continuous quantity with a</span>
<span class="sd">        list of discrete intervals</span>

<span class="sd">    Example: discrete values = [1, 2, 3, 4]</span>

<span class="sd">    We define thresholds tau_1_2, tau_2_3 and tau_3_4.</span>
<span class="sd">    In order to impose that the threshold are sorted, we actually define</span>
<span class="sd">        tau_1_2 = tau_parameter</span>
<span class="sd">        tau_2_3 = tau_1_2 + diff2</span>
<span class="sd">        tau_3_4 = tau_2_3 + diff3</span>

<span class="sd">    The probability that the discrete value is 2, say, is the</span>
<span class="sd">    probability that the continuous value lies between tau_1_2 and</span>
<span class="sd">    tau_2_3, where the probability distribution is logistic.</span>

<span class="sd">    :param continuous_value: continuous quantity to mapping</span>
<span class="sd">    :type continuous_value: biogeme.expressions.Expression</span>

<span class="sd">    :param list_of_discrete_values: discrete values</span>
<span class="sd">    :type list_of_discrete_values: list(int)</span>

<span class="sd">    :param tau_parameter: parameter for the first threshold</span>
<span class="sd">    :type tau_parameter: biogeme.expressions.Beta</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ordered_likelihood</span><span class="p">(</span>
        <span class="n">continuous_value</span><span class="o">=</span><span class="n">continuous_value</span><span class="p">,</span>
        <span class="n">list_of_discrete_values</span><span class="o">=</span><span class="n">list_of_discrete_values</span><span class="p">,</span>
        <span class="n">tau_parameter</span><span class="o">=</span><span class="n">tau_parameter</span><span class="p">,</span>
        <span class="n">cdf</span><span class="o">=</span><span class="n">dist</span><span class="o">.</span><span class="n">logisticcdf</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="ordered_probit">
<a class="viewcode-back" href="../../../code/biogeme/models/models_orig.html#biogeme.models.models_orig.ordered_probit">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ordered_probit</span><span class="p">(</span><span class="n">continuous_value</span><span class="p">,</span> <span class="n">list_of_discrete_values</span><span class="p">,</span> <span class="n">tau_parameter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ordered probit model that maps a continuous quantity with a</span>
<span class="sd">        list of discrete intervals</span>

<span class="sd">    Example: discrete values = [1, 2, 3, 4]</span>

<span class="sd">    We define thresholds tau_1_2, tau_2_3 and tau_3_4.</span>
<span class="sd">    In order to impose that the threshold are sorted, we actually define</span>
<span class="sd">        tau_1_2 = tau_parameter</span>
<span class="sd">        tau_2_3 = tau_1_2 + diff2</span>
<span class="sd">        tau_3_4 = tau_2_3 + diff3</span>

<span class="sd">    The probability that the discrete value is 2, say, is the</span>
<span class="sd">    probability that the continuous value lies between tau_1_2 and</span>
<span class="sd">    tau_2_3, where the probability distribution is normal.</span>

<span class="sd">    :param continuous_value: continuous quantity to mapping</span>
<span class="sd">    :type continuous_value: biogeme.expressions.Expression</span>

<span class="sd">    :param list_of_discrete_values: discrete values</span>
<span class="sd">    :type list_of_discrete_values: list(int)</span>

<span class="sd">    :param tau_parameter: parameter for the first threshold</span>
<span class="sd">    :type tau_parameter: biogeme.expressions.Beta</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ordered_likelihood</span><span class="p">(</span>
        <span class="n">continuous_value</span><span class="o">=</span><span class="n">continuous_value</span><span class="p">,</span>
        <span class="n">list_of_discrete_values</span><span class="o">=</span><span class="n">list_of_discrete_values</span><span class="p">,</span>
        <span class="n">tau_parameter</span><span class="o">=</span><span class="n">tau_parameter</span><span class="p">,</span>
        <span class="n">cdf</span><span class="o">=</span><span class="n">expr</span><span class="o">.</span><span class="n">bioNormalCdf</span><span class="p">,</span>
    <span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Michel Bierlaire.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>